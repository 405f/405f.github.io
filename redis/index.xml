<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on </title>
    <link>https://dtest11.github.io/redis/</link>
    <description>Recent content in Redis on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Jun 2020 21:25:54 +0000</lastBuildDate><atom:link href="https://dtest11.github.io/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>堆排序</title>
      <link>https://dtest11.github.io/redis/sort-heap/</link>
      <pubDate>Tue, 02 Jun 2020 21:25:54 +0000</pubDate>
      
      <guid>https://dtest11.github.io/redis/sort-heap/</guid>
      <description>package heap import &amp;#34;fmt&amp;#34; func swap(A []int, i, j int) { A[i], A[j] = A[j], A[i] } //// heapify 最大堆的性质, 建立一个最大堆 //// A[left] &amp;lt;A[i] &amp;amp;&amp;amp; A[right] &amp;lt; A[i] //通过下标进行最大值比较过程 func heapify(arr []int, heapSize, i int) { left := 2*i + 1 right := 2*i + 2 largest := i if left &amp;lt; heapSize &amp;amp;&amp;amp; arr[left] &amp;gt; arr[largest] { largest = left } if right &amp;lt; heapSize &amp;amp;&amp;amp; arr[right] &amp;gt; arr[largest] { largest = right } if largest !</description>
    </item>
    
    <item>
      <title>redis-skiplist</title>
      <link>https://dtest11.github.io/redis/redis-skiplist/</link>
      <pubDate>Mon, 06 Jan 2020 22:37:02 +0000</pubDate>
      
      <guid>https://dtest11.github.io/redis/redis-skiplist/</guid>
      <description>AVL 平衡树 定义 左右子树的高度差不超过1
特性 左右子树的值有如下的特性, 因此 AVL 树在查询和排序方面有优越性,时间复杂度是 logn
 left &amp;lt; head &amp;lt;right 一些问题, 由于AVL 为了保持, 上面的特性, 因此AVL 树在Insert , Delete 过程中涉及到了,节点的位置调整, 这个也就是左旋,右旋,(我没有弄懂这个,写不出来)
skiplist redis 引入跳表是为了解决什么问题 为了在大量的数据中位置数据的有序,同时要在数据的查询,删除,过程 取得一个平衡的位置,使得insert, delete 不会有很大的时间复杂度,而跳表具有这个特性, 并且从编码实现方面来说要比红黑书,AVL, B tree , B plus tree 简单的多.
redis 在那些地方使用了跳表 redis 的有序数据集的底层实现,都使用了跳表 sorted set(有序字典) 大概的实现 skiplist 就是一个链表 其中从链表的一个Node 来看,他是一个高层楼房, 其中每一层 都串联到 同样海拔高度的 Node 的楼房,
那么查找一个数据的过程变变成了从最高的海拔 ,不停的往下找,同时, 选择前进或者后退
https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</description>
    </item>
    
    <item>
      <title>redis-分布式锁</title>
      <link>https://dtest11.github.io/redis/redis-lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dtest11.github.io/redis/redis-lock/</guid>
      <description>&lt;p&gt;一个简单的需求， 高并发的时候用户不能重复注册， 因为后台API， 是多个节点部署的， 我们并不是单台机器，那么怎么保证用户频繁的提交注册请求不会导致业务逻辑重复执行，（这里我们不讨论数据库设计的时候是有唯一的主键的，例如手机号码）其实很简单，我们提供一个中心化的服务，在API执行的时候先从这个服务去检查下自己需不需要执行，那么其实这个问题最后就变成了一个锁的问题。由于我们的服务是多个实例，分布部署的，是分布式，那么这个锁也就是分布式锁。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
