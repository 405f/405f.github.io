<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>hello</title>
		<link>https://dtest11.github.io/</link>
		<description>Recent content on dtest11.github.io</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Tue, 02 Jun 2020 21:25:54 +0000</lastBuildDate>
		
		<atom:link href="https://dtest11.github.io/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>堆排序</title>
			<link>https://dtest11.github.io/redis/sort-heap/</link>
			<pubDate>Tue, 02 Jun 2020 21:25:54 +0000</pubDate>
			
			<guid>https://dtest11.github.io/redis/sort-heap/</guid>
			<description>
			
				package heap import "fmt" func swap(A []int, i, j int) { A[i], A[j] = A[j], A[i] } //// heapify 最大堆的性质, 建立一个最大堆 //// A[left] <A[i] && A[right] < A[i] //通过下标进行最大值比较过程 func heapify(arr []int, heapSize, i int) { left := 2*i + 1 right := 2*i + 2 largest := i if left < heapSize && arr[left] > arr[largest] { …</A[i]>
			
			</description>
		</item>
		<item>
			<title>cri-Container Runtime Interface</title>
			<link>https://dtest11.github.io/posts/cri/</link>
			<pubDate>Mon, 09 Mar 2020 12:42:40 +0000</pubDate>
			
			<guid>https://dtest11.github.io/posts/cri/</guid>
			<description>
			
				引用： [https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/](Introducing Container Runtime Interface (CRI) in …
			
			</description>
		</item>
		<item>
			<title>hello</title>
			<link>https://dtest11.github.io/posts/hello/</link>
			<pubDate>Sun, 01 Mar 2020 11:59:55 +0000</pubDate>
			
			<guid>https://dtest11.github.io/posts/hello/</guid>
			<description>
			
				主要特性  支持“标准”Markdown / CommonMark和Github风格的语法，也可变身为代码编辑器； 支持实时预览、图片（跨域）上传、预格式文本/代码/表格插入、代码折叠、搜索替换、只读模式、自定义样式主题和多语言语法高亮等功能； 支持ToC（Table of …
			
			</description>
		</item>
		<item>
			<title>opentracing---分布式链路追踪</title>
			<link>https://dtest11.github.io/posts/opentracing/</link>
			<pubDate>Sun, 01 Mar 2020 11:59:55 +0000</pubDate>
			
			<guid>https://dtest11.github.io/posts/opentracing/</guid>
			<description>
			
				分布式链路追踪 追踪程序的调用链，统计调用过程中的一些基本信息，如 SQL 执行时间， http 响应时间
opentracing / jaegertracing 这个2个项目 都是CNCF的成员，已经是大规模在使用中的项目， 我们今天主要看下jaegertracing 是如何使 …
			
			</description>
		</item>
		<item>
			<title>mysql- 索引</title>
			<link>https://dtest11.github.io/mysql/mysql-index/</link>
			<pubDate>Fri, 28 Feb 2020 16:37:53 +0000</pubDate>
			
			<guid>https://dtest11.github.io/mysql/mysql-index/</guid>
			<description>
			
				总结一下mysql 索引的相关内容，复盘重新学习下。
for what 索引是 为了在大量数据中快速查找数据而出现的，
索引实现方式 索引的底层实现有各种各样的方式，最常见的有 哈希表，有序数组，和搜索树.
 哈系表： 这个无需多说，就是输入之后经过hash 然后得到位置，然后从 …
			
			</description>
		</item>
		<item>
			<title>go-1.14-release-note</title>
			<link>https://dtest11.github.io/golang/go-1-14-release-not/</link>
			<pubDate>Fri, 28 Feb 2020 10:42:55 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/go-1-14-release-not/</guid>
			<description>
			
				official href 1.14 Release Note
. https://blog.golang.org/go1.14
. https://golang.org/doc/go1.14
重点变更 . Module support in the go command is …
			
			</description>
		</item>
		<item>
			<title>k8s-fronted-backend</title>
			<link>https://dtest11.github.io/k8s/k8s-fronted-backend/</link>
			<pubDate>Thu, 27 Feb 2020 21:54:39 +0000</pubDate>
			
			<guid>https://dtest11.github.io/k8s/k8s-fronted-backend/</guid>
			<description>
			
				TODO 微软镜像加速下载 https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md …
			
			</description>
		</item>
		<item>
			<title>k8s ingress controller 实践</title>
			<link>https://dtest11.github.io/k8s/k8s-ingress-controller/</link>
			<pubDate>Thu, 27 Feb 2020 17:02:29 +0000</pubDate>
			
			<guid>https://dtest11.github.io/k8s/k8s-ingress-controller/</guid>
			<description>
			
				k8s 集群的环境是1.7， 三台aliyun ECS 首先部署了ingress controller 使用kubernate-ingress-nginx https://github.com/kubernetes/ingress-nginx,在这个repo 中我们看到这个目录 …
			
			</description>
		</item>
		<item>
			<title>字典的实现</title>
			<link>https://dtest11.github.io/golang/map/</link>
			<pubDate>Tue, 18 Feb 2020 12:10:51 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/map/</guid>
			<description>
			
				字典 字典的是具有O(1)的时间复杂度
哈希函数 实现字典通常使用哈系表，哈系表最重要的问题是解决哈系冲突，解决哈系冲突我们最常用的就是2个方法
开放定址法 对与哈系函数 f(x) = index,查找数列中该index 是否已经有存放的元素，如果有元素的话，那么走到下一个位 …
			
			</description>
		</item>
		<item>
			<title>asleep-deadlock!</title>
			<link>https://dtest11.github.io/golang/golang_sleep-deadlock/</link>
			<pubDate>Sun, 09 Feb 2020 12:07:24 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/golang_sleep-deadlock/</guid>
			<description>
			
				写goroutines 偶尔会碰到
fatal error: all goroutines are asleep - deadlock! deaklock 的定义 A deadlock happens when a group of goroutines are waiting …
			
			</description>
		</item>
		<item>
			<title>grpc-server</title>
			<link>https://dtest11.github.io/golang/grpc-server/</link>
			<pubDate>Sat, 08 Feb 2020 16:40:52 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/grpc-server/</guid>
			<description>
			
				grpc server 的源码分析 grpc 的server 是处理http 链接的入口， client 传递的数据最终都是被传递到了server 端
func main() { lis, err := net.Listen("tcp", port) if err != nil …
			
			</description>
		</item>
		<item>
			<title>grpc 编码格式分析-ProtoBuffer</title>
			<link>https://dtest11.github.io/golang/grpc-proto/</link>
			<pubDate>Fri, 07 Feb 2020 16:16:25 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/grpc-proto/</guid>
			<description>
			
				grpc ProtoBuffer 性能高的原因 代码里的对象基本分两类，一类的长度是固定的，比如 int32 占用 32 比特，double 占用 64 比特；另一类的长度是变化的，比如字符串。所以，在设计编码的时候， 首先就得区分这两种情况。最简单的办法就是用一个字节表示类型， …
			
			</description>
		</item>
		<item>
			<title>golang defer 的一些总结</title>
			<link>https://dtest11.github.io/golang/defer/</link>
			<pubDate>Sun, 02 Feb 2020 17:05:44 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/defer/</guid>
			<description>
			
				defer 和return return 中返回的值 是不受defer 中的逻辑影响的，具体看个例子, return 是先执行的
package main import "fmt" func record() int { var counter = 10 // counter = …
			
			</description>
		</item>
		<item>
			<title>Go中并发控制</title>
			<link>https://dtest11.github.io/golang/golang-concurrency/</link>
			<pubDate>Wed, 15 Jan 2020 13:55:29 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/golang-concurrency/</guid>
			<description>
			
				goroutines https://seancarpenter.io/posts/concurrency_in_go/
https://www.cnblogs.com/sunsky303/p/11077634.html
package main import ( "fmt" …
			
			</description>
		</item>
		<item>
			<title>db-index</title>
			<link>https://dtest11.github.io/mysql/db-index/</link>
			<pubDate>Mon, 06 Jan 2020 23:22:35 +0000</pubDate>
			
			<guid>https://dtest11.github.io/mysql/db-index/</guid>
			<description>
			
				一个事务引发的血案 真的是理论永远是理论,只有实践了才知道, 最近在写用户注册的服务,由于用户注册的过程中需要在多张表里面插入数据, 因此我用了事务来做这个,ACID 还是知道的, 但是,坑人的是,这些表的主键都是从一个种子表中取得的, 因此,坑就出现了,在事务中,需要多次从种子 …
			
			</description>
		</item>
		<item>
			<title>redis-skiplist</title>
			<link>https://dtest11.github.io/redis/redis-skiplist/</link>
			<pubDate>Mon, 06 Jan 2020 22:37:02 +0000</pubDate>
			
			<guid>https://dtest11.github.io/redis/redis-skiplist/</guid>
			<description>
			
				AVL 平衡树 定义 左右子树的高度差不超过1
特性 左右子树的值有如下的特性, 因此 AVL 树在查询和排序方面有优越性,时间复杂度是 logn
 left < head <right 一些问题, 由于AVL 为了保持, 上面的特性, 因此AVL 树在Insert , …
			
			</description>
		</item>
		<item>
			<title>golang-errors</title>
			<link>https://dtest11.github.io/golang/golang-errors/</link>
			<pubDate>Mon, 06 Jan 2020 21:22:07 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/golang-errors/</guid>
			<description>
			
				error 只是一个接口的实现 我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的
type error interface { Error() string } 如这里的T1 就是一个error
type T1 …
			
			</description>
		</item>
		<item>
			<title>docker-operate</title>
			<link>https://dtest11.github.io/k8s/docker-operate/</link>
			<pubDate>Sat, 04 Jan 2020 14:53:27 +0000</pubDate>
			
			<guid>https://dtest11.github.io/k8s/docker-operate/</guid>
			<description>
			
				停止所有的container docker stop $(docker ps -q) 清除 所有的docker container docker rm $(docker ps -a -q) 清除 所有的磁盘挂载 docker volume prune without sudo …
			
			</description>
		</item>
		<item>
			<title>rancher-k8s-deploy</title>
			<link>https://dtest11.github.io/k8s/rancher-k8s-deploy/</link>
			<pubDate>Fri, 03 Jan 2020 23:01:27 +0000</pubDate>
			
			<guid>https://dtest11.github.io/k8s/rancher-k8s-deploy/</guid>
			<description>
			
				Rancher install 如果之前安装过,需要清理 /opt/rancher 文件夹
 docker run -d -p 80:80 -p 443:443 \ --restart=unless-stopped \ -v …
			
			</description>
		</item>
		<item>
			<title>gitlab-deploy.md</title>
			<link>https://dtest11.github.io/golang/gitlab-deploy-md/</link>
			<pubDate>Fri, 03 Jan 2020 22:49:16 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/gitlab-deploy-md/</guid>
			<description>
			
				gitlab 部署 sudo docker run --detach \ --hostname 47.110.136.181 \ --publish 443:443 --publish 80:80 --publish 23:22 \ --name gitlab \ …
			
			</description>
		</item>
		<item>
			<title>debug-k8s</title>
			<link>https://dtest11.github.io/k8s/debug-k8s/</link>
			<pubDate>Fri, 03 Jan 2020 22:40:01 +0000</pubDate>
			
			<guid>https://dtest11.github.io/k8s/debug-k8s/</guid>
			<description>
			
				查看pod 状态 kubectl -n kube-ops describe pod runner-svzx4ujw-project-1-concurrent-0qd6hq 删除pod kubectl -n kube-ops delete pods …
			
			</description>
		</item>
		<item>
			<title>go-Benchmark</title>
			<link>https://dtest11.github.io/golang/go-benchmark/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/go-benchmark/</guid>
			<description>
			
				如何写benchmark 我们有函数如下：
package writeT func Fib(n int) int { if n < 2 { return n } return Fib(n-1) + Fib(n-2) } benchmark 的代码应该是以xxx_test.go 结 …
			
			</description>
		</item>
		<item>
			<title>go-sync-map</title>
			<link>https://dtest11.github.io/golang/golang_sync_map/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://dtest11.github.io/golang/golang_sync_map/</guid>
			<description>
			
				sync map Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or …
			
			</description>
		</item>
		<item>
			<title>redis-分布式锁</title>
			<link>https://dtest11.github.io/redis/redis-lock/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://dtest11.github.io/redis/redis-lock/</guid>
			<description>
			
				一个简单的需求， 高并发的时候用户不能重复注册， 因为后台API， 是多个节点部署的， 我们并不是单台机器，那么怎么保证用户频繁的提交注册请求不会导致业务逻辑重复执行，（这里我们不讨论数据库设计的时候是有唯一的主键的，例如手机号码）其实很简单，我们提供一个中心化的服务，在API执 …
			
			</description>
		</item>
		
	</channel>
</rss>
