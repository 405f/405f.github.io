<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Txt site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Dtest11&#39;s Awesome Hugo Site">
    <meta name="generator" content="Hugo 0.61.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/tags/index.xml" rel="alternate" type="application/rss+xml" title="Txt site" />
      <link href="/tags/index.xml" rel="feed" type="application/rss+xml" title="Txt site" />
      
    
    
    <meta property="og:title" content="Tags" />
<meta property="og:description" content="Dtest11&#39;s Awesome Hugo Site" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://dtest11.github.io/tags/" />
<meta property="og:updated_time" content="2020-06-02T21:25:54+00:00" />
<meta itemprop="name" content="Tags">
<meta itemprop="description" content="Dtest11&#39;s Awesome Hugo Site"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tags"/>
<meta name="twitter:description" content="Dtest11&#39;s Awesome Hugo Site"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Txt site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Tags
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/tags/four" class="link blue hover-black">
            Tag: four
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/posts/cri/" class="link black dim">
        cri-Container Runtime Interface
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用： [https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/](Introducing Container Runtime Interface (CRI) in Kubernetes)
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/golang" class="link blue hover-black">
            Tag: golang
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/go-1-14-release-not/" class="link black dim">
        go-1.14-release-note
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="official-href">official href</h2>
<p>1.14 Release Note</p>
<p>. <a href="https://blog.golang.org/go1.14">https://blog.golang.org/go1.14</a></p>
<p>. <a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a></p>
<h2 id="heading">重点变更</h2>
<p>. Module support in the go command is now ready for production use. We encourage all users to migrate to go modules for dependency management.</p>
<p>. Embedding interfaces with overlapping method sets</p>
<p>. Improved defer performance</p>
<p>. Goroutines are asynchronously preemptible</p>
<p>. The page allocator is more efficient</p>
<p>. Internal timers are more efficient</p>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/map/" class="link black dim">
        字典的实现
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      字典 字典的是具有O(1)的时间复杂度
哈希函数 实现字典通常使用哈系表，哈系表最重要的问题是解决哈系冲突，解决哈系冲突我们最常用的就是2个方法
开放定址法 对与哈系函数 f(x) = index,查找数列中该index 是否已经有存放的元素，如果有元素的话，那么走到下一个位置index+1, 重复如此的步骤，直到找到空闲的位置
拉链法 对于拉链法，数据结构是 列表+ 链表 ，来实现的， 实现过程具体如下：
对于哈希函数 f（x) = index , 对于列表的index 位置， index 存放的是链表， 从链表的开始位置遍历，如果这个key 存在，那么就更新这个value, 如果没有那么就最后追加到链表的末尾，
字典实现过程中一般会碰到的问题  字典的具体实现方法（hash table?) 解决哈系函数的方法 （拉链法， 开放定址法） 字典的扩容 方式（当字典的容量不够的时候，如何扩容）  针对以上的问题研究下go 的字典实现方法 go 源码中对于map 的定义 / A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. 	// Make sure this stays in sync with the compiler&#39;s definition.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang_sleep-deadlock/" class="link black dim">
        asleep-deadlock!
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      写goroutines 偶尔会碰到
fatal error: all goroutines are asleep - deadlock! deaklock 的定义 A deadlock happens when a group of goroutines are waiting for each other and none of them is able to proceed.  首先channel 是用来在groutines中用来传递信息的，那么在单个grountine中讨论channel 是没有意义的  channel 的定义 我们声明一个chnnel如如下的方式
messages :=make(chan string) 对于channel 我们分为有缓冲的，没有缓冲的， 单向(只读，只写)
message := make(chan string) // 无缓冲 message :=make(chan string, 10) // 有10 个缓冲的通道 message :=make( chan &lt;-int) // 只能写 message := make( &lt;-chan int) //只能读取的channel  有缓冲的通道， 我们可以往里面写入数据，不会造成阻塞， 或者死锁  package main import &#34;fmt&#34; func main() { messages := make(chan string, 10) messages &lt;- &#34;hello world&#34; messages &lt;- &#34;hello world again&#34; messages &lt;- &#34;hello world next time&#34; fmt.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/grpc-server/" class="link black dim">
        grpc-server
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      grpc server 的源码分析 grpc 的server 是处理http 链接的入口， client 传递的数据最终都是被传递到了server 端
func main() { lis, err := net.Listen(&#34;tcp&#34;, port) if err != nil { log.Fatalf(&#34;failed to listen: %v&#34;, err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, &amp;server{}) if err := s.Serve(lis); err != nil { log.Fatalf(&#34;failed to serve: %v&#34;, err) } } 先创建一个server对象， 并对其添加控制， 如最大接受的消息长度 然后注册protocal buffer 的定义文件
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/grpc-proto/" class="link black dim">
        grpc 编码格式分析-ProtoBuffer
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      grpc ProtoBuffer 性能高的原因 代码里的对象基本分两类，一类的长度是固定的，比如 int32 占用 32 比特，double 占用 64 比特；另一类的长度是变化的，比如字符串。所以，在设计编码的时候， 首先就得区分这两种情况。最简单的办法就是用一个字节表示类型，紧接着传输数据，如下图所示：
type data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节有 256 种取值。我们可以为每一种类型分配一个编号。解码的时候先读出第一个字节，根据不同的类型再读取对应长度的数据。对于定长类型的数据， 解码到此就完成了。对于变长类型数据，我们还需要确认数据的长度。如何传输这个长度呢？以 string 为例。先传一个字节表示长度，再传真正的字符串，如下图所示：
type=string length data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节能表示的最大值是 255，所以字符串的长度不能超过 255 字节。这肯定是不行的。怎么办？如果我们使用两个字节，则最大能表示的长度就会扩展到 65535 字节。 这对于一般的使用场景也就够用了。但如果要传输更长的字符串呢？再加字节吗
因为长度是变化的，所以使用固定长度字节表示很不灵活：太短则表示范围太小；太长则传输效率太低。如果我们用 4 个字节表示长度 1，则为 0x00 0x00 0x00 0x01，高 31 位都是零，没有传递任何信息。
如果能去掉这些零效率不就提上来吗？比如，对于长度 1 只传 0x01，对于长度 4112 只传 0x1010。但就，这样做会导致另外一个问题：如何确定表示长度所需要的字节数量。我们好像以回到了原点。为了表示字符串的长度，我们引入了长度字段，现在长度字段的长度也是不确定的了。
Base 128 Varints  引用 https://zhuanlan.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/defer/" class="link black dim">
        golang defer 的一些总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      defer 和return return 中返回的值 是不受defer 中的逻辑影响的，具体看个例子, return 是先执行的
package main import &#34;fmt&#34; func record() int { var counter = 10 // counter = 10  defer func() { counter += 10 fmt.Println(&#34;defer中执行counter=&#34;, counter) // 这里的counter 不影响return 返回的 	}() return counter // counter = 10 } func main() { res := record() fmt.Println(&#34;最后返回的结果：&#34;, res) } /**** defer中执行counter= 20 最后返回的结果： 10 */ defer 中传递参数 package main import &#34;fmt&#34; func add(a, b int) int { sum := a + b fmt.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang-concurrency/" class="link black dim">
        Go中并发控制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      goroutines https://seancarpenter.io/posts/concurrency_in_go/
https://www.cnblogs.com/sunsky303/p/11077634.html
package main import ( &#34;fmt&#34; &#34;time&#34; ) func doWork(work int) { time.Sleep(5 * time.Second) fmt.Printf(&#34;Work done %d \n&#34;, work) } func main() { go doWork(1) go doWork(2) doWork(3) time.Sleep(10 * time.Second) } 上面的代码输出完全是随机的,3,2,1 的次序 随机的
Work done 3 Work done 2 Work done 1 channel channel 是 goroutine 用来通信的方式, 同时我们也可以使用channel 来控制grountine 的执行次序 channel 是引用传递的
channel 的类别
  有缓冲的通道(不会阻塞当前代码的执行) make(chan int , 10)
  没有缓冲通道的(阻塞当前代码的执行) make(chan int)
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang-errors/" class="link black dim">
        golang-errors
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      error 只是一个接口的实现 我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的
type error interface { Error() string } 如这里的T1 就是一个error
type T1 struct { Desc string } func (t1 T1) Error() string { return fmt.Sprintf(&#34;T1 error :%s&#34;, t1.Desc) } 1.3 之前的我们 catch错误 在以前我们经常用nil 去比较代码是否发生错误, 如下面的例子
func main() { var err error err =Throw() if err != nil { panic(err) } fmt.Println(&#34;right&#34;) } 判断错误的类型 要判断错误的来源是那个我们可以使用下面的技术
var ErrNotFound = errors.New(&#34;not found&#34;) if err == ErrNotFound { // something wasn&#39;t found } 同样我们也可以使用类型断言,来确定这个错误是由那个具体的对象抛出的
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/gitlab-deploy-md/" class="link black dim">
        gitlab-deploy.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      gitlab 部署 sudo docker run --detach \ --hostname 47.110.136.181 \ --publish 443:443 --publish 80:80 --publish 23:22 \ --name gitlab \ --restart always \ --volume /srv/gitlab/config:/etc/gitlab \ --volume /srv/gitlab/logs:/var/log/gitlab \ --volume /srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 部署太慢可以先拉去镜像 dockerhub.azk8s.cn/library/gitlab/gitlab-ce
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/go-benchmark/" class="link black dim">
        go-Benchmark
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="benchmark">如何写benchmark</h3>
<p>我们有函数如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">writeT</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">2</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
}

</code></pre></div>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang_sync_map/" class="link black dim">
        go-sync-map
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      sync map Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time. The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content. The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/k8s" class="link blue hover-black">
            Tag: k8s
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">K8s</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/k8s/k8s-fronted-backend/" class="link black dim">
        k8s-fronted-backend
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      TODO 微软镜像加速下载 https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md
dockerhub.azk8s.cn/google-samples/hello-go-gke:1.0 gcr.azk8s.cn//:gcr.azk8s.cn/google-samples/hello-go-gke:1.0
部署后端服务 . deployment
## service/access/hello.yaml  apiVersion: apps/v1 kind: Deployment metadata: name: hello namespace: backend spec: selector: matchLabels: app: hello tier: backend track: stable replicas: 2 template: metadata: labels: app: hello tier: backend track: stable spec: containers: - name: hello image: &#34;nginx&#34; ports: - name: http containerPort: 80 . service
## service/access/hello-service.yaml  apiVersion: v1 kind: Service metadata: name: hello namespace: backend spec: selector: app: hello tier: backend ports: - protocol: TCP port: 80 targetPort: http 
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">K8s</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/k8s/k8s-ingress-controller/" class="link black dim">
        k8s ingress controller 实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      k8s 集群的环境是1.7， 三台aliyun ECS 首先部署了ingress controller 使用kubernate-ingress-nginx https://github.com/kubernetes/ingress-nginx,在这个repo 中我们看到这个目录中ingress-nginx/deploy/static/ 已经有一部分的yaml 文件， 我们首先部署一个Deployment（nginx-ingress-controller）,https://github.com/kubernetes/ingress-nginx/blob/master/deploy/static/mandatory.yaml
执行部署命令 kubectl create -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml, 命令完成之后再次查看下是否成功
kubectl get pods --all-namespaces -l app.kubernetes.io/name=ingress-nginx 输出
NAMESPACE NAME READY STATUS RESTARTS AGE ingress-nginx nginx-ingress-controller-7f74f657bd-s6gft 1/1 Running 0 107s 部署ingress-nginx-controller service 通过上面的2个步骤，只是将ingress-nginx-controller 部署到了k8s 集群中， 并没有暴露出来， 接下来我们使用service 暴露出，
### service-nodeport.yaml apiVersion: v1 kind: Service metadata: name: ingress-nginx namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx spec: type: NodePort ports: - name: http port: 80 targetPort: 80 protocol: TCP - name: https port: 443 targetPort: 443 protocol: TCP selector: app.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">K8s</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/k8s/docker-operate/" class="link black dim">
        docker-operate
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      停止所有的container docker stop $(docker ps -q) 清除 所有的docker container docker rm $(docker ps -a -q) 清除 所有的磁盘挂载 docker volume prune 
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">K8s</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/k8s/rancher-k8s-deploy/" class="link black dim">
        rancher-k8s-deploy
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Rancher install 如果之前安装过,需要清理 /opt/rancher 文件夹
 docker run -d -p 80:80 -p 443:443 \ --restart=unless-stopped \ -v /opt/rancher:/var/lib/rancher \ rancher/rancher:latest 选择 
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">K8s</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/k8s/debug-k8s/" class="link black dim">
        debug-k8s
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      查看pod 状态 kubectl -n kube-ops describe pod runner-svzx4ujw-project-1-concurrent-0qd6hq 删除pod kubectl -n kube-ops delete pods runner-svzx4ujw-project-1-concurrent-0qd6hq &ndash;grace-period=0 &ndash;force
查看pod 中的container kubectl get pods &ndash;all-namespaces -o=jsonpath=&rsquo;{range .items[]}{&quot;\n&rdquo;}{.metadata.name}{&quot;:\t&rdquo;}{range .spec.containers[]}{.image}{&quot;, &ldquo;}{end}{end}&rsquo; |
sort
查看pod 中container 的日志 kubectl logs &lt;pod_name&gt; -c &lt;container_name&gt;
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/mysql" class="link blue hover-black">
            Tag: mysql
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Mysql</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/mysql/mysql-index/" class="link black dim">
        mysql- 索引
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>总结一下mysql 索引的相关内容，复盘重新学习下。</p>
<h2 id="for-what">for what</h2>
<p>索引是 为了在大量数据中快速查找数据而出现的，</p>
<h2 id="heading">索引实现方式</h2>
<p>索引的底层实现有各种各样的方式，最常见的有 <strong>哈希表</strong>，<strong>有序数组</strong>，和<strong>搜索树</strong>.</p>
<ol>
<li>哈系表： 这个无需多说，就是输入之后经过hash 然后得到位置，然后从该位置去寻找数据， 这个肯定会出现冲突，他只适合等值查找的， 不能查找某个范围区间的。</li>
<li>有序数组： 这个可以精确查找，和范围查找都是可以的。但是在数据更新的过程中，必须要循环遍历数组，插入数据的时候，后半部分都要整体的移动，效率是很低的。因此这个方式，只适合数据静态数据，数据不会变动。</li>
<li>搜索树： 我们知道二叉树的数据性质是 left &lt;head &lt;  right ， 而在实际的数据库实现中可能使用的是N叉树。</li>
</ol>
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Mysql</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/mysql/db-index/" class="link black dim">
        db-index
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一个事务引发的血案 真的是理论永远是理论,只有实践了才知道, 最近在写用户注册的服务,由于用户注册的过程中需要在多张表里面插入数据, 因此我用了事务来做这个,ACID 还是知道的, 但是,坑人的是,这些表的主键都是从一个种子表中取得的, 因此,坑就出现了,在事务中,需要多次从种子表中去获取主键(select update 操作) 导致在多个事物中,会争夺对种子表的锁, 死锁就这样产生了, 最后的解决办法,就是提前申请好种子,将申请种子的这个过成放在食物的外面执行,不过我还是觉得用数据库的来做种子还是有问题了,这个可以直接做个服务, 像雪花算法,都是可以在并发情况下生种子的,
索引的问题 最近写的接口还是有点慢的,感觉自己对索引这部分的知识还是掌握的不够透彻, 重新再做个总结
为什么我使用了索引，查询还是慢？ 今天看到篇文章不错,做个读后记录
索引的分类 索引有 聚簇索引,联合索引, 主键索引
 唯一索引 (在一个字段或者在多个字段上做索引, 这个字段是不会重复的) 主键索引 (这个也是属于唯一索引,primariykey) 聚集索引 / 非聚集索引(该索引的顺序决定了表中数据的物理存储顺序) 组合索引  查看执行计划 sql 语句我们可用通过查看执行计划,来看查询的具体实现过程, 是使用了索引还是全表扫描
TODO 
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/opentracing" class="link blue hover-black">
            Tag: opentracing
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/posts/opentracing/" class="link black dim">
        opentracing---分布式链路追踪
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="heading">分布式链路追踪</h2>
<p>追踪程序的调用链，统计调用过程中的一些基本信息，如 SQL 执行时间， http 响应时间</p>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/redis" class="link blue hover-black">
            Tag: redis
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Redis</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/redis/sort-heap/" class="link black dim">
        堆排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      package heap import &#34;fmt&#34; func swap(A []int, i, j int) { A[i], A[j] = A[j], A[i] } //// heapify 最大堆的性质, 建立一个最大堆 //// A[left] &lt;A[i] &amp;&amp; A[right] &lt; A[i] //通过下标进行最大值比较过程 func heapify(arr []int, heapSize, i int) { left := 2*i + 1 right := 2*i + 2 largest := i if left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest] { largest = left } if right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest] { largest = right } if largest !
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Redis</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/redis/redis-skiplist/" class="link black dim">
        redis-skiplist
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      AVL 平衡树 定义 左右子树的高度差不超过1
特性 左右子树的值有如下的特性, 因此 AVL 树在查询和排序方面有优越性,时间复杂度是 logn
 left &lt; head &lt;right 一些问题, 由于AVL 为了保持, 上面的特性, 因此AVL 树在Insert , Delete 过程中涉及到了,节点的位置调整, 这个也就是左旋,右旋,(我没有弄懂这个,写不出来)
skiplist redis 引入跳表是为了解决什么问题 为了在大量的数据中位置数据的有序,同时要在数据的查询,删除,过程 取得一个平衡的位置,使得insert, delete 不会有很大的时间复杂度,而跳表具有这个特性, 并且从编码实现方面来说要比红黑书,AVL, B tree , B plus tree 简单的多.
redis 在那些地方使用了跳表 redis 的有序数据集的底层实现,都使用了跳表 sorted set(有序字典) 大概的实现 skiplist 就是一个链表 其中从链表的一个Node 来看,他是一个高层楼房, 其中每一层 都串联到 同样海拔高度的 Node 的楼房,
那么查找一个数据的过程变变成了从最高的海拔 ,不停的往下找,同时, 选择前进或者后退
https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Redis</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/redis/redis-lock/" class="link black dim">
        redis-分布式锁
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>一个简单的需求， 高并发的时候用户不能重复注册， 因为后台API， 是多个节点部署的， 我们并不是单台机器，那么怎么保证用户频繁的提交注册请求不会导致业务逻辑重复执行，（这里我们不讨论数据库设计的时候是有唯一的主键的，例如手机号码）其实很简单，我们提供一个中心化的服务，在API执行的时候先从这个服务去检查下自己需不需要执行，那么其实这个问题最后就变成了一个锁的问题。由于我们的服务是多个实例，分布部署的，是分布式，那么这个锁也就是分布式锁。</p>
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/three" class="link blue hover-black">
            Tag: three
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/posts/cri/" class="link black dim">
        cri-Container Runtime Interface
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用： [https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/](Introducing Container Runtime Interface (CRI) in Kubernetes)
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/two" class="link blue hover-black">
            Tag: two
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/posts/cri/" class="link black dim">
        cri-Container Runtime Interface
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用： [https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/](Introducing Container Runtime Interface (CRI) in Kubernetes)
    </div>
  </div>
</div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://dtest11.github.io/" >
    &copy;  Txt site 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
