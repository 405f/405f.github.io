<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on txt site</title>
    <link>https://dtest11.github.io/tags/golang/</link>
    <description>Recent content in golang on txt site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Fri, 28 Feb 2020 10:42:55 +0000</lastBuildDate>
    
	<atom:link href="https://dtest11.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>go-1.14-release-note</title>
      <link>https://dtest11.github.io/golang/go-1-14-release-not/</link>
      <pubDate>Fri, 28 Feb 2020 10:42:55 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/go-1-14-release-not/</guid>
      <description>&lt;h2 id=&#34;official-href&#34;&gt;official href&lt;/h2&gt;
&lt;p&gt;1.14 Release Note&lt;/p&gt;
&lt;p&gt;. &lt;a href=&#34;https://blog.golang.org/go1.14&#34;&gt;https://blog.golang.org/go1.14&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;. &lt;a href=&#34;https://golang.org/doc/go1.14&#34;&gt;https://golang.org/doc/go1.14&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;重点变更&lt;/h2&gt;
&lt;p&gt;. Module support in the go command is now ready for production use. We encourage all users to migrate to go modules for dependency management.&lt;/p&gt;
&lt;p&gt;. Embedding interfaces with overlapping method sets&lt;/p&gt;
&lt;p&gt;. Improved defer performance&lt;/p&gt;
&lt;p&gt;. Goroutines are asynchronously preemptible&lt;/p&gt;
&lt;p&gt;. The page allocator is more efficient&lt;/p&gt;
&lt;p&gt;. Internal timers are more efficient&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>字典的实现</title>
      <link>https://dtest11.github.io/golang/map/</link>
      <pubDate>Tue, 18 Feb 2020 12:10:51 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/map/</guid>
      <description>字典 字典的是具有O(1)的时间复杂度
哈希函数 实现字典通常使用哈系表，哈系表最重要的问题是解决哈系冲突，解决哈系冲突我们最常用的就是2个方法
开放定址法 对与哈系函数 f(x) = index,查找数列中该index 是否已经有存放的元素，如果有元素的话，那么走到下一个位置index+1, 重复如此的步骤，直到找到空闲的位置
拉链法 对于拉链法，数据结构是 列表+ 链表 ，来实现的， 实现过程具体如下：
对于哈希函数 f（x) = index , 对于列表的index 位置， index 存放的是链表， 从链表的开始位置遍历，如果这个key 存在，那么就更新这个value, 如果没有那么就最后追加到链表的末尾，
字典实现过程中一般会碰到的问题  字典的具体实现方法（hash table?) 解决哈系函数的方法 （拉链法， 开放定址法） 字典的扩容 方式（当字典的容量不够的时候，如何扩容）  针对以上的问题研究下go 的字典实现方法 go 源码中对于map 的定义 / A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition.</description>
    </item>
    
    <item>
      <title>asleep-deadlock!</title>
      <link>https://dtest11.github.io/golang/golang_sleep-deadlock/</link>
      <pubDate>Sun, 09 Feb 2020 12:07:24 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/golang_sleep-deadlock/</guid>
      <description>写goroutines 偶尔会碰到
fatal error: all goroutines are asleep - deadlock! deaklock 的定义 A deadlock happens when a group of goroutines are waiting for each other and none of them is able to proceed.  首先channel 是用来在groutines中用来传递信息的，那么在单个grountine中讨论channel 是没有意义的  channel 的定义 我们声明一个chnnel如如下的方式
messages :=make(chan string) 对于channel 我们分为有缓冲的，没有缓冲的， 单向(只读，只写)
message := make(chan string) // 无缓冲 message :=make(chan string, 10) // 有10 个缓冲的通道 message :=make( chan &amp;lt;-int) // 只能写 message := make( &amp;lt;-chan int) //只能读取的channel  有缓冲的通道， 我们可以往里面写入数据，不会造成阻塞， 或者死锁  package main import &amp;#34;fmt&amp;#34; func main() { messages := make(chan string, 10) messages &amp;lt;- &amp;#34;hello world&amp;#34; messages &amp;lt;- &amp;#34;hello world again&amp;#34; messages &amp;lt;- &amp;#34;hello world next time&amp;#34; fmt.</description>
    </item>
    
    <item>
      <title>grpc-server</title>
      <link>https://dtest11.github.io/golang/grpc-server/</link>
      <pubDate>Sat, 08 Feb 2020 16:40:52 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/grpc-server/</guid>
      <description>grpc server 的源码分析 grpc 的server 是处理http 链接的入口， client 传递的数据最终都是被传递到了server 端
func main() { lis, err := net.Listen(&amp;#34;tcp&amp;#34;, port) if err != nil { log.Fatalf(&amp;#34;failed to listen: %v&amp;#34;, err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, &amp;amp;server{}) if err := s.Serve(lis); err != nil { log.Fatalf(&amp;#34;failed to serve: %v&amp;#34;, err) } } 先创建一个server对象， 并对其添加控制， 如最大接受的消息长度 然后注册protocal buffer 的定义文件</description>
    </item>
    
    <item>
      <title>grpc 编码格式分析-ProtoBuffer</title>
      <link>https://dtest11.github.io/golang/grpc-proto/</link>
      <pubDate>Fri, 07 Feb 2020 16:16:25 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/grpc-proto/</guid>
      <description>grpc ProtoBuffer 性能高的原因 代码里的对象基本分两类，一类的长度是固定的，比如 int32 占用 32 比特，double 占用 64 比特；另一类的长度是变化的，比如字符串。所以，在设计编码的时候， 首先就得区分这两种情况。最简单的办法就是用一个字节表示类型，紧接着传输数据，如下图所示：
type data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节有 256 种取值。我们可以为每一种类型分配一个编号。解码的时候先读出第一个字节，根据不同的类型再读取对应长度的数据。对于定长类型的数据， 解码到此就完成了。对于变长类型数据，我们还需要确认数据的长度。如何传输这个长度呢？以 string 为例。先传一个字节表示长度，再传真正的字符串，如下图所示：
type=string length data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节能表示的最大值是 255，所以字符串的长度不能超过 255 字节。这肯定是不行的。怎么办？如果我们使用两个字节，则最大能表示的长度就会扩展到 65535 字节。 这对于一般的使用场景也就够用了。但如果要传输更长的字符串呢？再加字节吗
因为长度是变化的，所以使用固定长度字节表示很不灵活：太短则表示范围太小；太长则传输效率太低。如果我们用 4 个字节表示长度 1，则为 0x00 0x00 0x00 0x01，高 31 位都是零，没有传递任何信息。
如果能去掉这些零效率不就提上来吗？比如，对于长度 1 只传 0x01，对于长度 4112 只传 0x1010。但就，这样做会导致另外一个问题：如何确定表示长度所需要的字节数量。我们好像以回到了原点。为了表示字符串的长度，我们引入了长度字段，现在长度字段的长度也是不确定的了。
Base 128 Varints  引用 https://zhuanlan.</description>
    </item>
    
    <item>
      <title>golang defer 的一些总结</title>
      <link>https://dtest11.github.io/golang/defer/</link>
      <pubDate>Sun, 02 Feb 2020 17:05:44 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/defer/</guid>
      <description>defer 和return return 中返回的值 是不受defer 中的逻辑影响的，具体看个例子, return 是先执行的
package main import &amp;#34;fmt&amp;#34; func record() int { var counter = 10 // counter = 10  defer func() { counter += 10 fmt.Println(&amp;#34;defer中执行counter=&amp;#34;, counter) // 这里的counter 不影响return 返回的 	}() return counter // counter = 10 } func main() { res := record() fmt.Println(&amp;#34;最后返回的结果：&amp;#34;, res) } /**** defer中执行counter= 20 最后返回的结果： 10 */ defer 中传递参数 package main import &amp;#34;fmt&amp;#34; func add(a, b int) int { sum := a + b fmt.</description>
    </item>
    
    <item>
      <title>Go中并发控制</title>
      <link>https://dtest11.github.io/golang/golang-concurrency/</link>
      <pubDate>Wed, 15 Jan 2020 13:55:29 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/golang-concurrency/</guid>
      <description>goroutines https://seancarpenter.io/posts/concurrency_in_go/
https://www.cnblogs.com/sunsky303/p/11077634.html
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func doWork(work int) { time.Sleep(5 * time.Second) fmt.Printf(&amp;#34;Work done %d \n&amp;#34;, work) } func main() { go doWork(1) go doWork(2) doWork(3) time.Sleep(10 * time.Second) } 上面的代码输出完全是随机的,3,2,1 的次序 随机的
Work done 3 Work done 2 Work done 1 channel channel 是 goroutine 用来通信的方式, 同时我们也可以使用channel 来控制grountine 的执行次序 channel 是引用传递的
channel 的类别
  有缓冲的通道(不会阻塞当前代码的执行) make(chan int , 10)
  没有缓冲通道的(阻塞当前代码的执行) make(chan int)</description>
    </item>
    
    <item>
      <title>golang-errors</title>
      <link>https://dtest11.github.io/golang/golang-errors/</link>
      <pubDate>Mon, 06 Jan 2020 21:22:07 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/golang-errors/</guid>
      <description>error 只是一个接口的实现 我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的
type error interface { Error() string } 如这里的T1 就是一个error
type T1 struct { Desc string } func (t1 T1) Error() string { return fmt.Sprintf(&amp;#34;T1 error :%s&amp;#34;, t1.Desc) } 1.3 之前的我们 catch错误 在以前我们经常用nil 去比较代码是否发生错误, 如下面的例子
func main() { var err error err =Throw() if err != nil { panic(err) } fmt.Println(&amp;#34;right&amp;#34;) } 判断错误的类型 要判断错误的来源是那个我们可以使用下面的技术
var ErrNotFound = errors.New(&amp;#34;not found&amp;#34;) if err == ErrNotFound { // something wasn&amp;#39;t found } 同样我们也可以使用类型断言,来确定这个错误是由那个具体的对象抛出的</description>
    </item>
    
    <item>
      <title>gitlab-deploy.md</title>
      <link>https://dtest11.github.io/golang/gitlab-deploy-md/</link>
      <pubDate>Fri, 03 Jan 2020 22:49:16 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/gitlab-deploy-md/</guid>
      <description>gitlab 部署 sudo docker run --detach \ --hostname 47.110.136.181 \ --publish 443:443 --publish 80:80 --publish 23:22 \ --name gitlab \ --restart always \ --volume /srv/gitlab/config:/etc/gitlab \ --volume /srv/gitlab/logs:/var/log/gitlab \ --volume /srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 部署太慢可以先拉去镜像 dockerhub.azk8s.cn/library/gitlab/gitlab-ce</description>
    </item>
    
    <item>
      <title>go-Benchmark</title>
      <link>https://dtest11.github.io/golang/go-benchmark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/go-benchmark/</guid>
      <description>&lt;h3 id=&#34;benchmark&#34;&gt;如何写benchmark&lt;/h3&gt;
&lt;p&gt;我们有函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;writeT&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Fib&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Fib&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Fib&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>go-sync-map</title>
      <link>https://dtest11.github.io/golang/golang_sync_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://dtest11.github.io/golang/golang_sync_map/</guid>
      <description>sync map Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time. The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content. The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys.</description>
    </item>
    
  </channel>
</rss>