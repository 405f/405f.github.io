<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title></title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.61.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/golang/index.xml" rel="alternate" type="application/rss+xml" title="" />
      <link href="/golang/index.xml" rel="feed" type="application/rss+xml" title="" />
      
    
    
    <meta property="og:title" content="Golangs" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://dtest11.github.io/golang/" />
<meta property="og:updated_time" content="2020-02-28T10:42:55+00:00" />
<meta itemprop="name" content="Golangs">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golangs"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Golangs
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/go-1-14-release-not/" class="link black dim">
        go-1.14-release-note
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h2 id="official-href">official href</h2>
<p>1.14 Release Note</p>
<p>. <a href="https://blog.golang.org/go1.14">https://blog.golang.org/go1.14</a></p>
<p>. <a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a></p>
<h2 id="heading">重点变更</h2>
<p>. Module support in the go command is now ready for production use. We encourage all users to migrate to go modules for dependency management.</p>
<p>. Embedding interfaces with overlapping method sets</p>
<p>. Improved defer performance</p>
<p>. Goroutines are asynchronously preemptible</p>
<p>. The page allocator is more efficient</p>
<p>. Internal timers are more efficient</p>
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/map/" class="link black dim">
        字典的实现
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      字典 字典的是具有O(1)的时间复杂度
哈希函数 实现字典通常使用哈系表，哈系表最重要的问题是解决哈系冲突，解决哈系冲突我们最常用的就是2个方法
开放定址法 对与哈系函数 f(x) = index,查找数列中该index 是否已经有存放的元素，如果有元素的话，那么走到下一个位置index+1, 重复如此的步骤，直到找到空闲的位置
拉链法 对于拉链法，数据结构是 列表+ 链表 ，来实现的， 实现过程具体如下：
对于哈希函数 f（x) = index , 对于列表的index 位置， index 存放的是链表， 从链表的开始位置遍历，如果这个key 存在，那么就更新这个value, 如果没有那么就最后追加到链表的末尾，
字典实现过程中一般会碰到的问题  字典的具体实现方法（hash table?) 解决哈系函数的方法 （拉链法， 开放定址法） 字典的扩容 方式（当字典的容量不够的时候，如何扩容）  针对以上的问题研究下go 的字典实现方法 go 源码中对于map 的定义 / A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. 	// Make sure this stays in sync with the compiler&#39;s definition.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang_sleep-deadlock/" class="link black dim">
        asleep-deadlock!
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      写goroutines 偶尔会碰到
fatal error: all goroutines are asleep - deadlock! deaklock 的定义 A deadlock happens when a group of goroutines are waiting for each other and none of them is able to proceed.  首先channel 是用来在groutines中用来传递信息的，那么在单个grountine中讨论channel 是没有意义的  channel 的定义 我们声明一个chnnel如如下的方式
messages :=make(chan string) 对于channel 我们分为有缓冲的，没有缓冲的， 单向(只读，只写)
message := make(chan string) // 无缓冲 message :=make(chan string, 10) // 有10 个缓冲的通道 message :=make( chan &lt;-int) // 只能写 message := make( &lt;-chan int) //只能读取的channel  有缓冲的通道， 我们可以往里面写入数据，不会造成阻塞， 或者死锁  package main import &#34;fmt&#34; func main() { messages := make(chan string, 10) messages &lt;- &#34;hello world&#34; messages &lt;- &#34;hello world again&#34; messages &lt;- &#34;hello world next time&#34; fmt.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/grpc-server/" class="link black dim">
        grpc-server
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      grpc server 的源码分析 grpc 的server 是处理http 链接的入口， client 传递的数据最终都是被传递到了server 端
func main() { lis, err := net.Listen(&#34;tcp&#34;, port) if err != nil { log.Fatalf(&#34;failed to listen: %v&#34;, err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, &amp;server{}) if err := s.Serve(lis); err != nil { log.Fatalf(&#34;failed to serve: %v&#34;, err) } } 先创建一个server对象， 并对其添加控制， 如最大接受的消息长度 然后注册protocal buffer 的定义文件
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/grpc-proto/" class="link black dim">
        grpc 编码格式分析-ProtoBuffer
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      grpc ProtoBuffer 性能高的原因 代码里的对象基本分两类，一类的长度是固定的，比如 int32 占用 32 比特，double 占用 64 比特；另一类的长度是变化的，比如字符串。所以，在设计编码的时候， 首先就得区分这两种情况。最简单的办法就是用一个字节表示类型，紧接着传输数据，如下图所示：
type data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节有 256 种取值。我们可以为每一种类型分配一个编号。解码的时候先读出第一个字节，根据不同的类型再读取对应长度的数据。对于定长类型的数据， 解码到此就完成了。对于变长类型数据，我们还需要确认数据的长度。如何传输这个长度呢？以 string 为例。先传一个字节表示长度，再传真正的字符串，如下图所示：
type=string length data +--------+--------+~~+--------+ |xxxxxxxx|xxxxxxxx| |xxxxxxxx| +--------+--------+~~+--------+ 7 0 7 0 7 0 一个字节能表示的最大值是 255，所以字符串的长度不能超过 255 字节。这肯定是不行的。怎么办？如果我们使用两个字节，则最大能表示的长度就会扩展到 65535 字节。 这对于一般的使用场景也就够用了。但如果要传输更长的字符串呢？再加字节吗
因为长度是变化的，所以使用固定长度字节表示很不灵活：太短则表示范围太小；太长则传输效率太低。如果我们用 4 个字节表示长度 1，则为 0x00 0x00 0x00 0x01，高 31 位都是零，没有传递任何信息。
如果能去掉这些零效率不就提上来吗？比如，对于长度 1 只传 0x01，对于长度 4112 只传 0x1010。但就，这样做会导致另外一个问题：如何确定表示长度所需要的字节数量。我们好像以回到了原点。为了表示字符串的长度，我们引入了长度字段，现在长度字段的长度也是不确定的了。
Base 128 Varints  引用 https://zhuanlan.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/defer/" class="link black dim">
        golang defer 的一些总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      defer 和return return 中返回的值 是不受defer 中的逻辑影响的，具体看个例子, return 是先执行的
package main import &#34;fmt&#34; func record() int { var counter = 10 // counter = 10  defer func() { counter += 10 fmt.Println(&#34;defer中执行counter=&#34;, counter) // 这里的counter 不影响return 返回的 	}() return counter // counter = 10 } func main() { res := record() fmt.Println(&#34;最后返回的结果：&#34;, res) } /**** defer中执行counter= 20 最后返回的结果： 10 */ defer 中传递参数 package main import &#34;fmt&#34; func add(a, b int) int { sum := a + b fmt.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang-concurrency/" class="link black dim">
        Go中并发控制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      goroutines https://seancarpenter.io/posts/concurrency_in_go/
https://www.cnblogs.com/sunsky303/p/11077634.html
package main import ( &#34;fmt&#34; &#34;time&#34; ) func doWork(work int) { time.Sleep(5 * time.Second) fmt.Printf(&#34;Work done %d \n&#34;, work) } func main() { go doWork(1) go doWork(2) doWork(3) time.Sleep(10 * time.Second) } 上面的代码输出完全是随机的,3,2,1 的次序 随机的
Work done 3 Work done 2 Work done 1 channel channel 是 goroutine 用来通信的方式, 同时我们也可以使用channel 来控制grountine 的执行次序 channel 是引用传递的
channel 的类别
  有缓冲的通道(不会阻塞当前代码的执行) make(chan int , 10)
  没有缓冲通道的(阻塞当前代码的执行) make(chan int)
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/golang-errors/" class="link black dim">
        golang-errors
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      error 只是一个接口的实现 我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的
type error interface { Error() string } 如这里的T1 就是一个error
type T1 struct { Desc string } func (t1 T1) Error() string { return fmt.Sprintf(&#34;T1 error :%s&#34;, t1.Desc) } 1.3 之前的我们 catch错误 在以前我们经常用nil 去比较代码是否发生错误, 如下面的例子
func main() { var err error err =Throw() if err != nil { panic(err) } fmt.Println(&#34;right&#34;) } 判断错误的类型 要判断错误的来源是那个我们可以使用下面的技术
var ErrNotFound = errors.New(&#34;not found&#34;) if err == ErrNotFound { // something wasn&#39;t found } 同样我们也可以使用类型断言,来确定这个错误是由那个具体的对象抛出的
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/gitlab-deploy-md/" class="link black dim">
        gitlab-deploy.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      gitlab 部署 sudo docker run --detach \ --hostname 47.110.136.181 \ --publish 443:443 --publish 80:80 --publish 23:22 \ --name gitlab \ --restart always \ --volume /srv/gitlab/config:/etc/gitlab \ --volume /srv/gitlab/logs:/var/log/gitlab \ --volume /srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 部署太慢可以先拉去镜像 dockerhub.azk8s.cn/library/gitlab/gitlab-ce
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Golang</span>
    <h1 class="f3 near-black">
      <a href="https://dtest11.github.io/golang/go-benchmark/" class="link black dim">
        go-Benchmark
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="benchmark">如何写benchmark</h3>
<p>我们有函数如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">writeT</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">2</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">Fib</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
}

</code></pre></div>
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/golang/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/golang/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/golang/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/golang/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/golang/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://dtest11.github.io/" >
    &copy; 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
